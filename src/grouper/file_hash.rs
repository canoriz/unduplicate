use std::fmt::Write;
use std::fs;
use std::io::{self, BufReader, Read, Seek};

#[derive(Eq, Debug, PartialEq, Copy, Clone)]
pub enum EigenOption {
    Fast(FastSamples),
    Head(u32),
    Length,
}

#[derive(Eq, Debug, PartialEq, Copy, Clone)]
pub struct FastSamples {
    samples: [u64; 32],
    cuts: u64,
}

impl Default for FastSamples {
    fn default() -> Self {
        // the default sampling positions, generated by random numbers
        FastSamples {
            samples: [
                66, 68, 107, 118, 131, 233, 313, 354, 362, 378, 427, 428, 432, 436, 454, 474, 501,
                611, 626, 681, 686, 692, 697, 746, 760, 774, 776, 869, 932, 980, 992, 1009,
            ],
            cuts: 1024,
        }
    }
}

#[derive(Eq, Debug, PartialEq, Ord, PartialOrd, Copy, Clone)]
pub enum HashResult {
    Empty,
    Fast([u8; 32]),
    Head([u8; 128]),
    Length(u64),
}

impl HashResult {
    pub fn hex(&self) -> String {
        let mut res = String::from("");
        match self {
            HashResult::Empty => {
                write!(&mut res, "0").expect("unable to write");
            }
            HashResult::Fast(arr) => {
                for b in arr {
                    write!(&mut res, "{:02x}", b).expect("unable to write");
                }
            }
            HashResult::Head(arr) => {
                for b in arr {
                    write!(&mut res, "{:02x}", b).expect("unable to write");
                }
            }
            HashResult::Length(len) => {
                write!(&mut res, "{}", len).expect("unable to wrte");
            }
        }
        res
    }
}

#[derive(PartialEq, Eq, Debug, Clone)]
pub struct FileInfo {
    pub path: String,
    pub len: u64,
    pub hash: HashResult,
}

impl FileInfo {
    pub fn new(path: &str) -> Result<Self, io::Error> {
        let f = fs::File::open(path)?;

        Ok(FileInfo {
            path: path.to_string(),
            len: f.metadata()?.len(),
            hash: HashResult::Empty,
        })
    }

    pub fn calc_hash(&mut self, op: EigenOption) -> Result<HashResult, io::Error> {
        let mut f = fs::File::open(&self.path)?;
        match op {
            EigenOption::Fast(FastSamples { samples, cuts }) => {
                let len = f.metadata()?.len();
                let mut reader = BufReader::new(&mut f);
                let bufchar = &mut [0u8; 1];

                let mut extractor =
                    |reader: &mut BufReader<&mut fs::File>, sample_pos| -> Result<u8, io::Error> {
                        reader.seek(io::SeekFrom::Start(len * sample_pos / cuts))?;
                        reader.read_exact(bufchar)?;
                        Ok(bufchar[0])
                    };

                let feature_vec = samples
                    .iter()
                    .map(|pos| extractor(&mut reader, pos))
                    .take(32);
                let mut result: [u8; 32] = [0; 32];

                // convert vec to array
                for (i, res) in feature_vec.into_iter().enumerate() {
                    match res {
                        Ok(r) => result[i] = r,
                        Err(e) => return Err(e),
                    }
                }

                self.hash = HashResult::Fast(result);
                Ok(self.hash)
            }
            EigenOption::Head(round) => {
                let mut buffer = [0u8; 128];
                let mut result = [0u8; 128];
                let mut reader = BufReader::new(f);

                for i in 0..round {
                    match reader.read(&mut buffer)? {
                        128 => (),
                        x => {
                            for b in result.iter_mut().skip(x) {
                                *b = 0u8;
                            }
                        }
                    }
                    for j in 0..128 {
                        result[j] = result[j] ^ buffer[j];
                    }
                }
                self.hash = HashResult::Head(result);
                Ok(self.hash)
            }
            EigenOption::Length => {
                self.hash = HashResult::Length(self.len);
                Ok(self.hash)
            }
        }
    }
}
